{"version":3,"sources":["webpack:///shortcode-tokenizer.js","webpack:///webpack/bootstrap a7914258ca61a73f8097","webpack:///./src/shortcode-tokenizer.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_toConsumableArray","arr","Array","isArray","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","getTokenType","str","CLOSE","SELF_CLOSING","OPEN","castValue","value","replace","test","parseFloat","toLowerCase","Token","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","RX_KEY","RX_PARAMS","RX_OPEN","RX_SELFCLOSING","rxParams","RegExp","substring","rxEnclosure","rxOpen","rxClose","rxSelfclosing","type","body","pos","arguments","undefined","this","children","params","isClosed","init","match","matchBody","initName","initParams","paramStr","reduce","paramToken","trim","equal","indexOf","rx","SyntaxError","token","ShortcodeTokenizer","input","options","strict","skipWhiteSpace","assign","buf","originalBuf","Error","tokens","allTokens","_next","push","apply","stack","ast","parent","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","canClose","pop","err","return","index","console","warn","set","TEXT","ERROR"],"mappings":"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","file":"shortcode-tokenizer.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!******************************************!*\\\n  !*** multi ./src/shortcode-tokenizer.js ***!\n  \\******************************************/\n/*! dynamic exports provided */\n/*! all exports used */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(/*! /Users/mblarsen/workspace/mblarsen/shortcode-tokenizer/src/shortcode-tokenizer.js */1);\n\n\n/***/ }),\n/* 1 */\n/*!************************************!*\\\n  !*** ./src/shortcode-tokenizer.js ***!\n  \\************************************/\n/*! exports provided: Token, default */\n/*! all exports used */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Token\", function() { return Token; });\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** @module ShortcodeTokenizer */\n\n/* tokens */\nvar TEXT = 'TEXT';\nvar ERROR = 'ERROR';\nvar OPEN = 'OPEN';\nvar CLOSE = 'CLOSE';\nvar SELF_CLOSING = 'SELF_CLOSING';\n\n/* eslint-disable */\n\n/* matches code name */\nvar RX_KEY = '[a-zA-Z][a-zA-Z0-9_-]*';\n\n/* matches paramters */\nvar RX_PARAM = RX_KEY + '=\\\\d+\\\\.\\\\d+' + // floats\n'|' + RX_KEY + '=\\\\d+' + // ints\n'|' + RX_KEY + '=(true|false|yes|no)' + // bools\n'|' + RX_KEY + '=\"[^\\\\]\"]*\"' + // double-qouted strings\n'|' + RX_KEY + '=\\'[^\\\\]\\']*\\'' + // single-qouted strings\n'|' + RX_KEY; // flags\nvar RX_PARAMS = '(?:(?:' + RX_PARAM + ')(?:(?!\\\\s+/?\\\\])\\\\s|))+';\n\n/* matches all code token types, used for quickly\n   finding potentia code tokens */\nvar RX_ENCLOSURE = '\\\\[\\\\/?[a-zA-Z][^\\\\]]+\\\\]';\n/* matches opening code tokens [row] */\nvar RX_OPEN = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\]';\n/* matches self-closing code tokens [row/] */\nvar RX_SELFCLOSING = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\s?\\\\/\\\\]';\n/* matches close code tokens [/row] */\nvar RX_CLOSE = '\\\\[\\\\/(' + RX_KEY + ')\\\\]';\n\n/* case-insensitive regular expressions */\nvar rxParams = new RegExp(RX_PARAMS.substring(0, RX_PARAMS.length - 1), 'ig');\nvar rxEnclosure = new RegExp(RX_ENCLOSURE, 'i');\nvar rxOpen = new RegExp(RX_OPEN, 'i');\nvar rxClose = new RegExp(RX_CLOSE, 'i');\nvar rxSelfclosing = new RegExp(RX_SELFCLOSING, 'i');\n\n/* eslint-enable */\n\n/**\n * Get token type based on token-string.\n *\n * Note: assuming that this is not a TEXT token\n *\n * @param {string} str\n * @returns {string} token type\n */\nfunction getTokenType(str) {\n  if (str[1] === '/') {\n    return CLOSE;\n  }\n  if (str[str.length - 2] === '/') {\n    return SELF_CLOSING;\n  }\n  return OPEN;\n}\n\n/**\n * Casts input string to native types.\n *\n * @param {string} value\n * @returns {*} mixed value\n */\nfunction castValue(value) {\n  value = value.replace(/(^['\"]|['\"]$)/g, '');\n  if (/^\\d+$/.test(value)) return +value;\n  if (/^\\d+.\\d+$/.test(value)) return parseFloat(value);\n  if (/^['\"]?(true|false|yes|no)['\"]?$/i.test(value)) {\n    value = value.replace(/(^['\"]|['\"]$)/g, '').toLowerCase();\n    return value === 'true' || value === 'yes';\n  }\n  return value;\n}\n\n/**\n * Token class is used both as a token during tokenization/lexing\n * and as a node in the resulting AST.\n *\n * @access private\n */\nvar Token = function () {\n  function Token(type, body) {\n    var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Token);\n\n    this.name = null;\n    this.type = type;\n    this.body = body;\n    this.pos = pos;\n    this.children = [];\n    this.params = {};\n    this.isClosed = type === SELF_CLOSING;\n    this.init();\n  }\n\n  /**\n   * @access private\n   */\n\n\n  _createClass(Token, [{\n    key: 'init',\n    value: function init() {\n      if (this.type !== TEXT && this.type !== ERROR) {\n        var match = this.matchBody();\n        this.initName(match);\n        if (match[2]) {\n          this.initParams(match[2]);\n        }\n      }\n    }\n\n    /**\n     * @access private\n     */\n\n  }, {\n    key: 'initName',\n    value: function initName(match) {\n      this.name = match[1];\n    }\n\n    /**\n     * @access private\n     */\n\n  }, {\n    key: 'initParams',\n    value: function initParams(paramStr) {\n      var match = paramStr.match(rxParams);\n      this.params = match.reduce(function (params, paramToken) {\n        paramToken = paramToken.trim();\n        var equal = paramToken.indexOf('=');\n        if (!~equal) {\n          params[paramToken] = true;\n        } else {\n          params[paramToken.substring(0, equal)] = castValue(paramToken.substring(equal + 1));\n        }\n        return params;\n      }, {});\n    }\n\n    /**\n     * @access private\n     */\n\n  }, {\n    key: 'matchBody',\n    value: function matchBody() {\n      var rx = void 0;\n      if (this.type === CLOSE) {\n        rx = rxClose;\n      } else if (this.type === OPEN) {\n        rx = rxOpen;\n      } else if (this.type === SELF_CLOSING) {\n        rx = rxSelfclosing;\n      } else {\n        throw new SyntaxError('Unknown token: ' + this.type);\n      }\n\n      var match = this.body.match(rx);\n      if (match === null) {\n        throw new SyntaxError('Invalid ' + this.type + ' token: ' + this.body);\n      }\n      return match;\n    }\n\n    /**\n     * Determines if this token can close the param token.\n     *\n     * @access public\n     * @param {Token} token another token\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'canClose',\n    value: function canClose(token) {\n      return this.name === token.name;\n    }\n  }]);\n\n  return Token;\n}();\n\n/**\n * Creates a new tokenizer.\n *\n * Pass in input as first param or later using `input()`\n *\n * @param {string} [input=null] Optional input to tokenize\n * @param {Object} [options] options object\n * @param {boolean} [options.strict=true] strict mode\n * @param {boolean} [options.skipWhiteSpace=false] will ignore tokens containing only white space (basically all \\s)\n */\n\nvar ShortcodeTokenizer = function () {\n  function ShortcodeTokenizer() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { strict: true, skipWhiteSpace: false };\n\n    _classCallCheck(this, ShortcodeTokenizer);\n\n    if (typeof options === 'boolean') {\n      options = { strict: options, skipWhiteSpace: false };\n    }\n    this.options = Object.assign({ strict: true, skipWhiteSpace: false }, options);\n    this.buf = null;\n    this.originalBuf = null;\n    this.pos = 0;\n    if (input) {\n      this.input(input);\n    }\n  }\n\n  /**\n   * @deprecated use options.strict\n   */\n\n\n  _createClass(ShortcodeTokenizer, [{\n    key: 'input',\n\n\n    /**\n     * Sets input buffer with a new input string.\n     *\n     * @param {string} input template string\n     * @throws {Error} Invalid input\n     * @returns {this} returns this for chaining\n     */\n    value: function input(_input) {\n      if (typeof _input !== 'string') {\n        throw new Error('Invalid input');\n      }\n\n      this.buf = this.originalBuf = _input;\n      this.pos = 0;\n      return this;\n    }\n\n    /**\n     * Resets input buffer and position to their origial values.\n     *\n     * @returns {this} returns this for chaining\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.buf = this.originalBuf;\n      this.pos = 0;\n      return this;\n    }\n\n    /**\n     * Creates a token generator.\n     *\n     * @throws {Error} Invalid input\n     * @returns {Token[]} An array of Token instances\n     */\n\n  }, {\n    key: 'tokens',\n    value: function tokens() {\n      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (input) {\n        this.input(input);\n      }\n\n      if (typeof this.buf !== 'string') {\n        throw new Error('Invalid input');\n      }\n\n      var tokens = [];\n      var allTokens = [];\n      while ((tokens = this._next()) !== null) {\n        tokens = Array.isArray(tokens) ? tokens : [tokens];\n        allTokens.push.apply(allTokens, _toConsumableArray(tokens));\n      }\n      return allTokens;\n    }\n\n    /**\n     * Uses the tokens generator to build an AST from the tokens.\n     *\n     * @see tokens\n     * @returns {array} an array of AST roots\n     */\n\n  }, {\n    key: 'ast',\n    value: function ast() {\n      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      var tokens = this.tokens(input);\n      var stack = [];\n      var ast = [];\n      var parent = null;\n      var token = void 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          token = _step.value;\n\n          if (token.type === TEXT) {\n            if (this.options.skipWhiteSpace && token.body.replace(/\\s+/g, '').length === 0) {\n              continue;\n            }\n            if (!parent) {\n              ast.push(token);\n            } else {\n              parent.children.push(token);\n            }\n          } else if (token.type === OPEN) {\n            if (!parent) {\n              parent = token;\n              ast.push(parent);\n            } else {\n              parent.children.push(token);\n              stack.push(parent);\n              parent = token;\n            }\n          } else if (token.type === CLOSE) {\n            if (!parent || !token.canClose(parent)) {\n              if (this.options.strict) {\n                throw new SyntaxError('Unmatched close token: ' + token.body);\n              } else {\n                var err = new Token(ERROR, token.body);\n                if (!parent) {\n                  ast.push(err);\n                } else {\n                  parent.children.push(err);\n                }\n              }\n            } else {\n              parent.isClosed = true;\n              parent = stack.pop();\n            }\n          } else if (token.type === SELF_CLOSING) {\n            if (!parent) {\n              ast.push(token);\n            } else {\n              parent.children.push(token);\n            }\n          } else {\n            throw new SyntaxError('Unknown token: ' + token.type);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (parent) {\n        if (this.options.strict) {\n          throw new SyntaxError('Unmatched open token: ' + parent.body);\n        } else {\n          ast.push(new Token(ERROR, token.body));\n        }\n      }\n      return ast;\n    }\n\n    /**\n     * Internal function used to retrieve the next token from the current\n     * position in the input buffer.\n     *\n     * @private\n     * @returns {Token} returns the next Token from the input buffer\n     */\n\n  }, {\n    key: '_next',\n    value: function _next() {\n      if (!this.buf) {\n        return null;\n      }\n\n      var match = this.buf.match(rxEnclosure);\n\n      // all text\n      if (match === null) {\n        var token = new Token(TEXT, this.buf, this.pos);\n        this.pos += this.buf.length;\n        this.buf = null;\n        return token;\n      }\n\n      var tokens = [];\n\n      // first part is text\n      if (match.index !== 0) {\n        tokens.push(new Token(TEXT, this.buf.substring(0, match.index), this.pos));\n      }\n\n      // matching token\n      tokens.push(new Token(getTokenType(match[0]), match[0], this.pos + match.index));\n\n      // shorten buffer\n      this.buf = this.buf.substring(match.index + match[0].length);\n      this.pos += match.index + match[0].length;\n      if (this.buf.length === 0) {\n        this.buf = null;\n      }\n      return tokens;\n    }\n  }, {\n    key: 'strict',\n    get: function get() {\n      console.warn('Deprecated: use options.strict instead');\n      return this.options.strict;\n    }\n\n    /**\n     * @deprecated use options.strict\n     */\n    ,\n    set: function set(value) {\n      console.warn('Deprecated: use options.strict = ' + value + ' instead');\n      this.options.strict = value;\n    }\n  }]);\n\n  return ShortcodeTokenizer;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ShortcodeTokenizer);\n\n\nObject.assign(ShortcodeTokenizer, {\n  TEXT: TEXT,\n  ERROR: ERROR,\n  OPEN: OPEN,\n  CLOSE: CLOSE,\n  SELF_CLOSING: SELF_CLOSING,\n  rxParams: rxParams,\n  rxEnclosure: rxEnclosure,\n  rxOpen: rxOpen,\n  rxClose: rxClose,\n  rxSelfclosing: rxSelfclosing\n});\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// shortcode-tokenizer.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a7914258ca61a73f8097","/** @module ShortcodeTokenizer */\n\n/* tokens */\nconst TEXT = 'TEXT'\nconst ERROR = 'ERROR'\nconst OPEN = 'OPEN'\nconst CLOSE = 'CLOSE'\nconst SELF_CLOSING = 'SELF_CLOSING'\n\n/* eslint-disable */\n\n/* matches code name */\nconst RX_KEY = '[a-zA-Z][a-zA-Z0-9_-]*'\n\n/* matches paramters */\nconst RX_PARAM =       RX_KEY + '=\\\\d+\\\\.\\\\d+' +         // floats\n                 '|' + RX_KEY + '=\\\\d+' +                // ints\n                 '|' + RX_KEY + '=(true|false|yes|no)' + // bools\n                 '|' + RX_KEY + '=\"[^\\\\]\"]*\"' +          // double-qouted strings\n                 '|' + RX_KEY + '=\\'[^\\\\]\\']*\\'' +       // single-qouted strings\n                 '|' + RX_KEY                            // flags\nconst RX_PARAMS = '(?:(?:' + RX_PARAM + ')(?:(?!\\\\s+/?\\\\])\\\\s|))+'\n\n/* matches all code token types, used for quickly\n   finding potentia code tokens */\nconst RX_ENCLOSURE   = '\\\\[\\\\/?[a-zA-Z][^\\\\]]+\\\\]'\n/* matches opening code tokens [row] */\nconst RX_OPEN        = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\]'\n/* matches self-closing code tokens [row/] */\nconst RX_SELFCLOSING = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\s?\\\\/\\\\]'\n/* matches close code tokens [/row] */\nconst RX_CLOSE       = '\\\\[\\\\/(' + RX_KEY + ')\\\\]'\n\n/* case-insensitive regular expressions */\nconst rxParams      = new RegExp(RX_PARAMS.substring(0, RX_PARAMS.length - 1), 'ig')\nconst rxEnclosure   = new RegExp(RX_ENCLOSURE, 'i')\nconst rxOpen        = new RegExp(RX_OPEN, 'i')\nconst rxClose       = new RegExp(RX_CLOSE, 'i')\nconst rxSelfclosing = new RegExp(RX_SELFCLOSING, 'i')\n\n/* eslint-enable */\n\n/**\n * Get token type based on token-string.\n *\n * Note: assuming that this is not a TEXT token\n *\n * @param {string} str\n * @returns {string} token type\n */\nfunction getTokenType(str) {\n  if (str[1] === '/') {\n    return CLOSE\n  }\n  if (str[str.length - 2] === '/') {\n    return SELF_CLOSING\n  }\n  return OPEN\n}\n\n/**\n * Casts input string to native types.\n *\n * @param {string} value\n * @returns {*} mixed value\n */\nfunction castValue(value) {\n  value = value.replace(/(^['\"]|['\"]$)/g, '')\n  if (/^\\d+$/.test(value)) return +value\n  if (/^\\d+.\\d+$/.test(value)) return parseFloat(value)\n  if (/^['\"]?(true|false|yes|no)['\"]?$/i.test(value)) {\n    value = value\n      .replace(/(^['\"]|['\"]$)/g, '')\n      .toLowerCase()\n    return value === 'true' || value === 'yes'\n  }\n  return value\n}\n\n/**\n * Token class is used both as a token during tokenization/lexing\n * and as a node in the resulting AST.\n *\n * @access private\n */\nexport class Token {\n  constructor(type, body, pos = 0) {\n    this.name = null\n    this.type = type\n    this.body = body\n    this.pos = pos\n    this.children = []\n    this.params = {}\n    this.isClosed = type === SELF_CLOSING\n    this.init()\n  }\n\n  /**\n   * @access private\n   */\n  init() {\n    if (this.type !== TEXT && this.type !== ERROR) {\n      const match = this.matchBody()\n      this.initName(match)\n      if (match[2]) {\n        this.initParams(match[2])\n      }\n    }\n  }\n\n  /**\n   * @access private\n   */\n  initName(match) {\n    this.name = match[1]\n  }\n\n  /**\n   * @access private\n   */\n  initParams(paramStr) {\n    const match = paramStr.match(rxParams)\n    this.params = match.reduce((params, paramToken) => {\n      paramToken = paramToken.trim()\n      let equal = paramToken.indexOf('=')\n      if (!~equal) {\n        params[paramToken] = true\n      } else {\n        params[paramToken.substring(0, equal)] = castValue(paramToken.substring(equal + 1))\n      }\n      return params\n    }, {})\n  }\n\n  /**\n   * @access private\n   */\n  matchBody() {\n    let rx\n    if (this.type === CLOSE) {\n      rx = rxClose\n    } else if (this.type === OPEN) {\n      rx = rxOpen\n    } else if (this.type === SELF_CLOSING) {\n      rx = rxSelfclosing\n    } else {\n      throw new SyntaxError('Unknown token: ' + this.type)\n    }\n\n    let match = this.body.match(rx)\n    if (match === null) {\n      throw new SyntaxError('Invalid ' + this.type + ' token: ' + this.body)\n    }\n    return match\n  }\n\n  /**\n   * Determines if this token can close the param token.\n   *\n   * @access public\n   * @param {Token} token another token\n   * @returns {boolean}\n   */\n  canClose(token) {\n    return this.name === token.name\n  }\n}\n\n/**\n * Creates a new tokenizer.\n *\n * Pass in input as first param or later using `input()`\n *\n * @param {string} [input=null] Optional input to tokenize\n * @param {Object} [options] options object\n * @param {boolean} [options.strict=true] strict mode\n * @param {boolean} [options.skipWhiteSpace=false] will ignore tokens containing only white space (basically all \\s)\n */\nexport default class ShortcodeTokenizer {\n\n  constructor(input = null, options = {strict: true, skipWhiteSpace: false}) {\n    if (typeof options === 'boolean') {\n      options = {strict: options, skipWhiteSpace: false}\n    }\n    this.options = Object.assign({strict: true, skipWhiteSpace: false}, options)\n    this.buf = null\n    this.originalBuf = null\n    this.pos = 0\n    if (input) {\n      this.input(input)\n    }\n  }\n\n  /**\n   * @deprecated use options.strict\n   */\n  get strict() {\n    console.warn(`Deprecated: use options.strict instead`)\n    return this.options.strict\n  }\n\n  /**\n   * @deprecated use options.strict\n   */\n  set strict(value) {\n    console.warn(`Deprecated: use options.strict = ${value} instead`)\n    this.options.strict = value\n  }\n\n  /**\n   * Sets input buffer with a new input string.\n   *\n   * @param {string} input template string\n   * @throws {Error} Invalid input\n   * @returns {this} returns this for chaining\n   */\n  input(input) {\n    if (typeof input !== 'string') {\n      throw new Error('Invalid input')\n    }\n\n    this.buf = this.originalBuf = input\n    this.pos = 0\n    return this\n  }\n\n  /**\n   * Resets input buffer and position to their origial values.\n   *\n   * @returns {this} returns this for chaining\n   */\n  reset() {\n    this.buf = this.originalBuf\n    this.pos = 0\n    return this\n  }\n\n  /**\n   * Creates a token generator.\n   *\n   * @throws {Error} Invalid input\n   * @returns {Token[]} An array of Token instances\n   */\n  tokens(input = null) {\n    if (input) {\n      this.input(input)\n    }\n\n    if (typeof this.buf !== 'string') {\n      throw new Error('Invalid input')\n    }\n\n    let tokens = []\n    let allTokens = []\n    while ((tokens = this._next()) !== null) {\n      tokens = Array.isArray(tokens) ? tokens : [tokens]\n      allTokens.push(...tokens)\n    }\n    return allTokens\n  }\n\n  /**\n   * Uses the tokens generator to build an AST from the tokens.\n   *\n   * @see tokens\n   * @returns {array} an array of AST roots\n   */\n  ast(input = null) {\n    let tokens = this.tokens(input)\n    let stack = []\n    let ast = []\n    let parent = null\n    let token\n    for (token of tokens) {\n      if (token.type === TEXT) {\n        if (this.options.skipWhiteSpace && token.body.replace(/\\s+/g, '').length === 0) {\n          continue\n        }\n        if (!parent) {\n          ast.push(token)\n        } else {\n          parent.children.push(token)\n        }\n      } else if (token.type === OPEN) {\n        if (!parent) {\n          parent = token\n          ast.push(parent)\n        } else {\n          parent.children.push(token)\n          stack.push(parent)\n          parent = token\n        }\n      } else if (token.type === CLOSE) {\n        if (!parent || !token.canClose(parent)) {\n          if (this.options.strict) {\n            throw new SyntaxError('Unmatched close token: ' + token.body)\n          } else {\n            let err = new Token(ERROR, token.body)\n            if (!parent) {\n              ast.push(err)\n            } else {\n              parent.children.push(err)\n            }\n          }\n        } else {\n          parent.isClosed = true\n          parent = stack.pop()\n        }\n      } else if (token.type === SELF_CLOSING) {\n        if (!parent) {\n          ast.push(token)\n        } else {\n          parent.children.push(token)\n        }\n      } else {\n        throw new SyntaxError('Unknown token: ' + token.type)\n      }\n    }\n    if (parent) {\n      if (this.options.strict) {\n        throw new SyntaxError('Unmatched open token: ' + parent.body)\n      } else {\n        ast.push(new Token(ERROR, token.body))\n      }\n    }\n    return ast\n  }\n\n  /**\n   * Internal function used to retrieve the next token from the current\n   * position in the input buffer.\n   *\n   * @private\n   * @returns {Token} returns the next Token from the input buffer\n   */\n  _next() {\n    if (!this.buf) {\n      return null\n    }\n\n    let match = this.buf.match(rxEnclosure)\n\n    // all text\n    if (match === null) {\n      let token = new Token(TEXT, this.buf, this.pos)\n      this.pos += this.buf.length\n      this.buf = null\n      return token\n    }\n\n    let tokens = []\n\n    // first part is text\n    if (match.index !== 0) {\n      tokens.push(new Token(\n        TEXT,\n        this.buf.substring(0, match.index),\n        this.pos\n      ))\n    }\n\n    // matching token\n    tokens.push(new Token(\n      getTokenType(match[0]),\n      match[0],\n      this.pos + match.index\n    ))\n\n    // shorten buffer\n    this.buf = this.buf.substring(match.index + match[0].length)\n    this.pos += match.index + match[0].length\n    if (this.buf.length === 0) {\n      this.buf = null\n    }\n    return tokens\n  }\n}\n\nObject.assign(ShortcodeTokenizer, {\n  TEXT,\n  ERROR,\n  OPEN,\n  CLOSE,\n  SELF_CLOSING,\n  rxParams,\n  rxEnclosure,\n  rxOpen,\n  rxClose,\n  rxSelfclosing\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/shortcode-tokenizer.js"],"sourceRoot":""}